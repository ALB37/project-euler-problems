'use strict';

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate(polygonal) numbers and are generated by the following formulae:

// Triangle	 	P3, n = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
// Square	 	P4, n = n2	 	1, 4, 9, 16, 25, ...
// Pentagonal	 	P5, n = n(3n−1) / 2	 	1, 5, 12, 22, 35, ...
// Hexagonal	 	P6, n = n(2n−1)	 	1, 6, 15, 28, 45, ...
// Heptagonal	 	P7, n = n(5n−3) / 2	 	1, 7, 18, 34, 55, ...
// Octagonal	 	P8, n = n(3n−2)	 	1, 8, 21, 40, 65, ...
// The ordered set of three 4 - digit numbers: 8128, 2882, 8281, has three interesting properties.

// The set is cyclic, in that the last two digits of each number is the first two digits of the next number(including the last number with the first).
// Each polygonal type: triangle(P3, 127 = 8128), square(P4, 91 = 8281), and pentagonal(P5, 44 = 2882), is represented by a different number in the set.
// This is the only set of 4 - digit numbers with this property.
// Find the sum of the only ordered set of six cyclic 4 - digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

const generateTriNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = (iter * (iter + 1)) / 2;
  }
  return outputArr;
};

const generateSqrNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = iter * iter;
  }
  return outputArr;
};

const generatePentNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = (iter * ((3 * iter) - 1)) / 2;
  }
  return outputArr;
};

const generateHexNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = iter * ((2 * iter) - 1);
  }
  return outputArr;
};

const generateHeptNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = (iter * ((5 * iter) - 3)) / 2;
  }
  return outputArr;
};

const generateOctNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = iter * ((3 * iter) - 2);
  }
  return outputArr;
};


const findCyclicSet = () => {
  const triArr = generateTriNum(10000).filter(e => e > 1000);
  const sqrArr = generateSqrNum(10000).filter(e => e > 1000);
  const pentArr = generatePentNum(10000).filter(e => e > 1000);
  const hexArr = generateHexNum(10000).filter(e => e > 1000);
  const heptArr = generateHeptNum(10000).filter(e => e > 1000);
  const octArr = generateOctNum(10000).filter(e => e > 1000);

  const _helper = (num, visitedArr, foundNums) => {
    if (visitedArr.filter(e => !e).length === 0) return foundNums;
    let rearDigits = num.toString().slice(2);
    if (Number(rearDigits) < 10) return null;
    for (let postFix = 10; postFix < 100; postFix++){
      let testNum = Number(rearDigits + postFix);
      for (let i in visitedArr){
        if (visitedArr[i]) continue;
        switch (Number(i)){
          case 0: {
            if (sqrArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(num);
              continueArr[i] = 1;
              const continuation = _helper(testNum, continueArr, moreFound);
              if (continuation) return continuation;
            }
            break;
          }
          case 1: {
            if (pentArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(num);
              continueArr[i] = 1;
              const continuation = _helper(testNum, continueArr, moreFound);
              if (continuation) return continuation;
            }
            break;
          }
          case 2: {
            if (hexArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(num);
              continueArr[i] = 1;
              const continuation = _helper(testNum, continueArr, moreFound);
              if (continuation) return continuation;
            }
            break;
          }
          case 3:{
            if (heptArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(num);
              continueArr[i] = 1;
              const continuation = _helper(testNum, continueArr, moreFound);
              if (continuation) return continuation;
            }
            break;
          }
          case 4: {
            if (octArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(num);
              continueArr[i] = 1;
              const continuation = _helper(testNum, continueArr, moreFound);
              if (continuation) return continuation;
            }
            break; 
          }
          
        }
      }
    }
    return null;
  };

  for (let num of triArr){
    const foundNums = _helper(num, [0, 0, 0, 0, 0], [num]);
    if (foundNums){
      const firstHalves = [];
      const lastHalves = [];
      for (let val of foundNums){
        firstHalves.push(val.toString().slice(0, 2));
        lastHalves.push(val.toString().slice(2));
      }
      let foundArr = true;
      for (let sub of firstHalves){
        if (!lastHalves.includes(sub)){
          foundArr = false;
          break;
        }
      }
      for (let sub of lastHalves){
        if (!firstHalves.includes(sub)) {
          foundArr = false;
          break;
        }
      }
      if (foundArr){
        console.log(foundNums);
      }
    }
  }
};

console.log(findCyclicSet());