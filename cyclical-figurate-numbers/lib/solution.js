'use strict';

// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate(polygonal) numbers and are generated by the following formulae:

// Triangle	 	P3, n = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
// Square	 	P4, n = n2	 	1, 4, 9, 16, 25, ...
// Pentagonal	 	P5, n = n(3n−1) / 2	 	1, 5, 12, 22, 35, ...
// Hexagonal	 	P6, n = n(2n−1)	 	1, 6, 15, 28, 45, ...
// Heptagonal	 	P7, n = n(5n−3) / 2	 	1, 7, 18, 34, 55, ...
// Octagonal	 	P8, n = n(3n−2)	 	1, 8, 21, 40, 65, ...
// The ordered set of three 4 - digit numbers: 8128, 2882, 8281, has three interesting properties.

// The set is cyclic, in that the last two digits of each number is the first two digits of the next number(including the last number with the first).
// Each polygonal type: triangle(P3, 127 = 8128), square(P4, 91 = 8281), and pentagonal(P5, 44 = 2882), is represented by a different number in the set.
// This is the only set of 4 - digit numbers with this property.
// Find the sum of the only ordered set of six cyclic 4 - digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

const generateTriNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = (iter * (iter + 1)) / 2;
  }
  return outputArr;
};

const generateSqrNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = iter * iter;
  }
  return outputArr;
};

const generatePentNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = (iter * ((3 * iter) - 1)) / 2;
  }
  return outputArr;
};

const generateHexNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = iter * ((2 * iter) - 1);
  }
  return outputArr;
};

const generateHeptNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = (iter * ((5 * iter) - 3)) / 2;
  }
  return outputArr;
};

const generateOctNum = limit => {
  const outputArr = [];
  let nextNumInSet = 1;
  let iter = 1;
  while (nextNumInSet < limit){
    outputArr.push(nextNumInSet);
    iter++;
    nextNumInSet = iter * ((3 * iter) - 2);
  }
  return outputArr;
};


const findCyclicSet = () => {
  // generate arrays for each of the figurate number sets
  // and filter so we only have 4 digit numbers
  const triArr = generateTriNum(10000).filter(e => e > 999);
  const sqrArr = generateSqrNum(10000).filter(e => e > 999);
  const pentArr = generatePentNum(10000).filter(e => e > 999);
  const hexArr = generateHexNum(10000).filter(e => e > 999);
  const heptArr = generateHeptNum(10000).filter(e => e > 999);
  const octArr = generateOctNum(10000).filter(e => e > 999);
  const foundSolutions = new Set();
  // the visited array will be our state;
  // a placeholder for figurate number types that are already included
  // in the foundNums arr
  const _helper = (num, visitedArr, foundNums) => {
    // check if each figurate number type is accounted for
    if (visitedArr.filter(e => !e).length === 0) {
      foundSolutions.add(foundNums);
      return;
    }
    let rearDigits = num.toString().slice(2);
    // the following condition leads to 3 digit numbers
    if (Number(rearDigits) < 10) return;
    for (let suffix = 10; suffix < 100; suffix++){
      // derive the beginning of the next number from
      // the last digits of the current number
      let testNum = Number(rearDigits + suffix);
      if (foundNums.includes(testNum)) continue;
      // next we will check the various paths where the suffix of
      // the current number works as the prefix of another
      // figurate number
      for (let i in visitedArr){
        // if we already have a certain figurate number,
        // we will not look at any more:
        if (visitedArr[i]) continue;
        // unfortunately, for in gives us a string
        // rather than a number:
        switch (Number(i)){
          case 0: {
            if (sqrArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(testNum);
              continueArr[i] = 1; 
              _helper(testNum, continueArr, moreFound);
            }
            break;
          }
          case 1: {
            if (pentArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(testNum);
              continueArr[i] = 1; 
              _helper(testNum, continueArr, moreFound);
            }
            break;
          }
          case 2: {
            if (hexArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(testNum);
              continueArr[i] = 1; 
              _helper(testNum, continueArr, moreFound);
            }
            break;
          }
          case 3:{
            if (heptArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(testNum);
              continueArr[i] = 1; 
              _helper(testNum, continueArr, moreFound);
            }
            break;
          }
          case 4: {
            if (octArr.includes(testNum)){
              const continueArr = [...visitedArr];
              const moreFound = [...foundNums];
              moreFound.push(testNum);
              continueArr[i] = 1; 
              _helper(testNum, continueArr, moreFound);
            }
            break; 
          }
          
        }
      }
    }
  };
  // generate possible answers starting with all triangle numbers
  for (let num of triArr){
    _helper(num, [0, 0, 0, 0, 0], [num]);
  }
  
  const uniqueNumberArrs = new Set();
  foundSolutions.forEach(arr => {
    // This code removes duplicates from an array;
    // This works because indexOf always returns the index
    // of the first found element.
    const filteredArr = arr.filter((e, i, a) => a.indexOf(e) === i);
    if (filteredArr.length === 6){
      uniqueNumberArrs.add(filteredArr);
    }
  });
  // the following is where we will narrow down the potential solutions
  // to the only solution which is cyclical
  let solution = null;
  uniqueNumberArrs.forEach(arr => {
    const firstHalves = [];
    const lastHalves = [];
    for (let val of arr){
      firstHalves.push(val.toString().slice(0, 2));
      lastHalves.push(val.toString().slice(2));
    }
    let foundArr = true;
    for (let half of firstHalves){
      if (!lastHalves.includes(half)){
        foundArr = false;
        break;
      }
    }
    for (let half of lastHalves){
      if (!foundArr) break;
      if (!firstHalves.includes(half)) {
        foundArr = false;
        break;
      }
    }
    if (foundArr){
      if (firstHalves.filter((e, i, a) => a.indexOf(e) === i).length === 6
          && lastHalves.filter((e, i, a) => a.indexOf(e) === i).length === 6)
        solution = arr;
    }
  });
  return solution;
};

console.log(findCyclicSet().reduce((ac, v) => ac + v, 0));